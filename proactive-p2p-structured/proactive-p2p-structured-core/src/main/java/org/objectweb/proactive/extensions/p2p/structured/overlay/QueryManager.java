package org.objectweb.proactive.extensions.p2p.structured.overlay;

import java.io.Serializable;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.objectweb.proactive.extensions.p2p.structured.api.messages.Reply;
import org.objectweb.proactive.extensions.p2p.structured.api.messages.Request;
import org.objectweb.proactive.extensions.p2p.structured.exceptions.DispatchException;
import org.objectweb.proactive.extensions.p2p.structured.exceptions.PostProcessException;
import org.objectweb.proactive.extensions.p2p.structured.exceptions.PreProcessException;
import org.objectweb.proactive.extensions.p2p.structured.messages.PendingReplyEntry;
import org.objectweb.proactive.extensions.p2p.structured.messages.RequestReplyMessage;
import org.objectweb.proactive.extensions.p2p.structured.messages.reply.AbstractReply;
import org.objectweb.proactive.extensions.p2p.structured.messages.request.AbstractRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The query manager is responsible for maintaining the state associated
 * to the queries dispatching. Therefore, it provides some useful methods
 * for the queries dispatching.
 * 
 * @author Laurent Pellegrino
 */
public abstract class QueryManager implements Serializable {
	
	private static final long serialVersionUID = 1L;

	private static final Logger logger = 
        LoggerFactory.getLogger(QueryManager.class);

    protected StructuredOverlay overlay;

    private Map<UUID, PendingReplyEntry> responsesReceived = 
        new ConcurrentHashMap<UUID, PendingReplyEntry>();

    public QueryManager() {

    }

    public abstract PendingReplyEntry mergeResponseReceived(AbstractReply<?> msg);

    /**
     * Method called just before the {@link #process(AbstractRequest)} method
     * in order to convert the specified query which is from the public API to
     * the private API but also to perform some operation on the specified query
     * which will be processed.
     * 
     * @param request
     *            the request to manipulate.
     *            
     * @return a request from the private API.
     * 
     * @throws PreProcessException
     *             if an error occurs during the pre-processing operation.
     */
    protected abstract AbstractRequest<?> preProcess(Request request) 
                                                throws PreProcessException;

    
    /**
     * Method called just after the {@link #process(AbstractRequest)} method
     * in order to convert the specified reply which is from the private API
     * to the public API but also to perform some operation on the specified
     * reply.
     * 
     * @param reply
     *            the reply generated by the process operation.
     *            
     * @return a reply from the public API.
     * 
     * @throws PostProcessException
     *             if an error occurs during the post-processing operation.
     */
    protected abstract Reply postProcess(
    								AbstractReply<?> reply) 
                                                throws PostProcessException;

	/**
	 * Dispatches the request on the overlay. It consists in performing three
	 * steps: first, to pre-process the query. Then, to process it. Finally, to
	 * post-process the reply returned by the process operation.
	 * 
	 * @param request
	 *            the {@link Request} to dispatch.
	 * 
	 * @return a {@link Reply} associated to the request type.
	 */
    public Reply dispatch(Request request) throws DispatchException {
        return this.postProcess(this.process(this.preProcess(request)));
    }

    /**
     * The process algorithm consists in dispatching the specified request  
     * into the overlay and to create a synchronization point in order to wait
     * and to retrieve the reply.
     * 
     * @param request
     *            the request to send over the overlay.
     *            
     * @return a reply according to the type of the request sent.
     */
    public AbstractReply<?> process(AbstractRequest<?> request) {
        if (logger.isDebugEnabled()) {
            logger.debug("QueryManager.process({}) from {}", request.getID(), this.overlay);
        }

        this.processInitialSent(request);
        this.waitForSynchronization(request);
        return this.processFinalReception(request);
    }

    protected void processInitialSent(AbstractRequest<?> msg) {
        msg.route(this.overlay);
    }

    protected void waitForSynchronization(AbstractRequest<?> msg) {
        if (logger.isDebugEnabled()) {
            StringBuffer buf = new StringBuffer();
            buf.append("Waiting for ");
            buf.append(this.responsesReceived.get(
                        msg.getID()).getExpectedRepliesCount());
            buf.append(" replies with uuid=");
            buf.append(msg.getID());
            buf.append(" on ");
            buf.append(this.overlay);
            QueryManager.logger.debug(buf.toString());
        }
        
        synchronized (this.responsesReceived) {
            while (this.responsesReceived.get(msg.getID()).getStatus() 
                        != PendingReplyEntry.Status.ALL_RESPONSES_RECEIVED) {
                try {
                    this.responsesReceived.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    protected AbstractReply<?> processFinalReception(RequestReplyMessage<?> msg) {
        AbstractReply<?> response = 
        	(AbstractReply<?>) this.responsesReceived
                .remove(msg.getID()).getResponse();
        // sets the delivery time for latency computation
        response.setDeliveryTime();

        if (logger.isDebugEnabled()) {
            logger.debug(
                    "Final response received for " + response.getID() 
                    + " on " + this.overlay);
        }

        return response;
    }

    public void putFinalResponseAndNotifyInitialSender(AbstractReply<?> response) {
        PendingReplyEntry entry = this.overlay.getRepliesReceived().get(
                response.getID());
                
        entry.incrementResponsesNumber(1);
        entry.setResponse(response);

        synchronized (this.overlay.getRepliesReceived()) {
            this.overlay.getRepliesReceived().notifyAll();
        }
    }

    public Map<UUID, PendingReplyEntry> getResponsesReceived() {
        return this.responsesReceived;
    }

    public <T extends RequestReplyMessage<?>> void route(T msg) {
        msg.route(this.overlay);
    }

    public void setOverlay(StructuredOverlay overlay) {
        this.overlay = overlay;
    }

}
